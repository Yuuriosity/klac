#+begin_src agda2

module homework.Day2 where

open import Prelude
open import Day1
open import Day2

#+end_src

* Задача 1 (★)
Вспомните определение списков и по аналогии создайте следующие типы данных:
  - Бинарные деревья, хранящие произвольные данные в листьях.
  - Бинарные деревья, хранящие произвольные данные в узлах.
#+begin_src agda2

data Treeₗ (A : Type₀) : Type₀ where
  Leafₗ : A → Treeₗ A
  Branchₗ : Treeₗ A → Treeₗ A → Treeₗ A

data Treeₙ (A : Type₀) : Type₀ where
  Leafₙ : Treeₙ A
  Branchₙ : A → Treeₙ A → Treeₙ A → Treeₙ A

#+end_src

* Задача 2 (★)
Напиишите функции обхода (left to right) для таких деревьев, чтобы собрать
содержимое дерева в список.
#+begin_src agda2

traverseₗ : {A : Type₀} → Treeₗ A → List A
traverseₗ (Leafₗ x) = x ∷ []
traverseₗ (Branchₗ l r) = traverseₗ l ++ traverseₗ r

traverseₙ : {A : Type₀} → Treeₙ A → List A
traverseₙ Leafₙ = []
traverseₙ (Branchₙ x l r) = x ∷ traverseₙ l ++ traverseₙ r

#+end_src

* Задача 3 (★★★)
В Haskell можно встретить функцию ~$~, позволяющую не писать лишние скобки,
применяя несколько функций одну за другой. В языке с зависимыми типами её
сигнатура более общая. Попробуйте написать максимально общую сигнатуру для
оператора композиции функций.
#+begin_src agda2

-- non-dependent
_$ₕ_ : {A B : Type₀} → (A → B) → A → B
f $ₕ x = f x

-- dependent
_$_ : {A : Type₀} {B : A → Type₀} → (f : (a : A) → B a) → (x : A) → B x
f $ x = f x

-- non-dependent
_∘ₕ_ : {A B C : Type₀} → (B → C) → (A → B) → (A → C)
(g ∘ₕ f) x = g (f x)

-- dependent
_∘_ : {A : Type₀} {B : A → Type₀} {C : (a : A) → B a → Type₀}
    → (g : {a : A} (b : B a) → C a b) → (f : (a : A) → B a) → (a : A) → C a (f a)
(g ∘ f) x = g (f x)

#+end_src
Эту задачу Thierry Coquand давал кому-то на защите диплома :-)

* Задача 4 (★★)
Теперь мы знаем, почему не удалось доказать половинку тавтологии ~contra~ из
прошлого дз. Попробуйте доказать её, используя закон исключённого третьего.

#+begin_src agda2

contra′ : {A B : 𝓤₀} → (lem : (Π X ꞉ 𝓤₀ , Dec X)) → (¬ B ⇒ ¬ A) → (A ⇒ B)
contra′ {A} {B} lem nbna x with lem B
... | inj₁ lb = lb
... | inj₂ rb = ex-falso-quodlibet (nbna rb x)

#+end_src

* Задача 5 (★★★)
Готтфрид Лейбниц характеризовал равенство таким образом:
для любых ~x~ и ~y~, они равны тогда и только тогда, когда для любого предиката ~P~,
~P(x)~ логически эквивалентно ~P(y)~.

Сформулируйте это равенство и покажите, что из равенства по Лейбницу следует и наше
обычное определение равенства, и наоборот.

#+begin_src agda2

_≡ₗ_ : {A : Type₀} → (x y : A) → Type₁
_≡ₗ_ {A} x y = Π P ꞉ (A → Type₀) , (P x → P y)

leibniz-to-martin-löf : {A : Type₀} (x y : A) → x ≡ₗ y → x ≡ y
leibniz-to-martin-löf x y eq = {!   !}

martin-löf-to-leibniz : {A : Type₀} (x y : A) → x ≡ y → x ≡ₗ y
martin-löf-to-leibniz x y eq = λ p → {!!}

#+end_src

* Задача 6 (★★)
Определите свойства чётности и нечётности для натуральных чисел. Покажите, что
чётность разрешима для любого натурального числа.

#+begin_src agda2

{-
Even : ℕ → Type₀
Even zero = ⊤
Even (suc zero) = ⊥
Even (suc (suc n)) = Even n

Odd : ℕ → Type₀
Odd zero = ⊥
Odd (suc zero) = ⊤
Odd (suc (suc n)) = Odd n
-}
mutual
  Even : ℕ → Type₀
  Even zero = ⊤
  Even (suc n) = Odd n

  Odd : ℕ → Type₀
  Odd zero = ⊥
  Odd (suc n) = Even n

even-dec : Π n ꞉ ℕ , Dec (Even n)
even-dec zero = inj₁ tt
even-dec (suc zero) = inj₂ id
even-dec (suc (suc n)) = even-dec n

#+end_src

* Задача 7 (★★)
Теперь вы сможете попробовать доказать следующую теорему:
#+begin_src agda2

lemma-suc : Π m ꞉ ℕ , (suc m > m)
lemma-suc zero = tt
lemma-suc (suc n) = lemma-suc n

lemma-evens> : Π m ꞉ ℕ , Π n ꞉ ℕ , (Even m ∧ Even n ∧ n > m ⇒ n > suc m)
lemma-evens> zero (suc (suc n)) (even-m , even-n , n>m) = n>m
lemma-evens> (suc (suc m))  (suc (suc n)) pf = lemma-evens> m n pf
-- lemma-evens> (suc (suc m)) zero (even-m , even-n , ())

hmm : Π m ꞉ ℕ , Π n ꞉ ℕ , (Even m ∧ Even n ∧ n > m ⇒ (Σ k ꞉ ℕ , k > m ∧ n > k ∧ Odd k))
hmm m n (even-m , even-n , n>m) = suc m , lemma-suc m , lemma-evens> m n (even-m , even-n , n>m)  , even-m

#+end_src
